#pragma once
#include "pch.h"
#include "Invulnerability.h"
#include "ModuleHook.h"
#include "MultilevelPointer.h"
#include "MidhookContextInterpreter.h"
#include "PointerManager.h"
#include "SettingsStateAndEvents.h"
#include "Datum.h"
#include "RuntimeExceptionHandler.h"
#include "DIContainer.h"
#include "IMCCStateHook.h"
#include "GetPlayerDatum.h"
#include "IMakeOrGetCheat.h"
#include "GetObjectAddress.h"
#include "DynamicStructFactory.h"

template <GameState::Value game> // templated only so we can have seperate versions of the static vars per game
class SimpleInvulnerabilityImpl : public InvulnerabilityImpl, public std::enable_shared_from_this<SimpleInvulnerabilityImpl<game>>
{
private:
	static inline SimpleInvulnerabilityImpl* instance = nullptr;
	GameState mGame;
	// event callbacks
	ScopedCallback<eventpp::CallbackList<void(bool&)>> mInvulnerabilityToggleCallbackHandle;

	// injected services
	gsl::not_null<std::shared_ptr<IMCCStateHook>> mccStateHook;
	gsl::not_null<std::shared_ptr<IMessagesGUI>> messagesGUI;
	gsl::not_null<std::shared_ptr<RuntimeExceptionHandler>> runtimeExceptions;
	gsl::not_null<std::shared_ptr<SettingsStateAndEvents>> settings;
	gsl::not_null<std::shared_ptr< GetPlayerDatum>> getPlayerDatum;
	gsl::not_null<std::shared_ptr< GetObjectAddress>> getObjectAddress;

	//data
	static inline std::shared_ptr<ModuleMidHook> invulnerabilityHook;
	static inline std::shared_ptr<MultilevelPointer> invulnerabilityFunction;
	static inline std::shared_ptr<MidhookContextInterpreter> invulnerabilityFunctionContext;
	enum class bipedDataFields { currentVehicleDatum };
	std::shared_ptr<DynamicStruct<bipedDataFields>> playerDataStruct;
	std::optional<std::shared_ptr<MultilevelPointer>> boardingText;
	std::optional<std::shared_ptr<MultilevelPointer>> boardingTextFlag;

	static void makeInvulnerable(SafetyHookContext& ctx)
	{
		LOG_ONCE(PLOG_DEBUG << "making object invulnerable");
		ctx.rflags = ctx.rflags | (1UL << 6);
	}

	static bool playerIsBoarding()
	{
		if (!instance->boardingText.has_value() || !instance->boardingTextFlag.has_value()) { LOG_ONCE(PLOG_DEBUG << "optional boarding pointers lacked values"); return false; }
		WCHAR resolvedBoardingText[8];
		int32_t resolvedBoardingTextFlag;
		if (!instance->boardingText.value()->readArrayData(&resolvedBoardingText[0], sizeof(resolvedBoardingText))) { LOG_ONCE(PLOG_DEBUG << "could not resolve boarding text"); return false; }
		if (!instance->boardingTextFlag.value()->readData(&resolvedBoardingTextFlag)) { LOG_ONCE(PLOG_DEBUG << "could not resolve boarding text flag"); return false; }
		if (resolvedBoardingTextFlag == 0xFFFFFFFF) { LOG_ONCE(PLOG_DEBUG << "boarding text was not active"); return false; }

		LOG_ONCE_CAPTURE(PLOG_DEBUG << "evaluating boarding text, current val: " << text, text = resolvedBoardingText);

			constexpr std::wstring_view actualBoardingText1 = L"to melee";
			constexpr std::wstring_view actualBoardingText2 = L"to plant";

		return wcsncmp(&resolvedBoardingText[0], actualBoardingText1.data(), sizeof(resolvedBoardingText)) || wcsncmp(&resolvedBoardingText[0], actualBoardingText2.data(), sizeof(resolvedBoardingText));
	}

	static void invulnerabilityHookFunction(SafetyHookContext& ctx)
	{
		LOG_ONCE(PLOG_DEBUG << "invulnerabilityHookFunction running");
		try
		{

			if (instance->settings->invulnerabilityNPCToggle->GetValue())
			{
				// when this option checked, we make EVERYTHING invuln- no need to check what's getting damaged
				return makeInvulnerable(ctx);
			}

			enum class param
			{
				currentlyDamagedUnitDatum
			};
			auto* ctxInterpreter = invulnerabilityFunctionContext.get();
			LOG_ONCE_CAPTURE(PLOG_DEBUG << "resolvedParam: " << resolvedParam, resolvedParam = ctxInterpreter->getParameterRef(ctx, (int)param::currentlyDamagedUnitDatum));

			Datum currentlyDamagedUnitDatum = *(Datum*)ctxInterpreter->getParameterRef(ctx, (int)param::currentlyDamagedUnitDatum);
			Datum playersCurrentDatum = instance->getPlayerDatum->getPlayerDatum();


			if (playersCurrentDatum == nullDatum) return; // might happen when the player is dead, depending on game version / pointer used

			// check if current actor is player
			if (currentlyDamagedUnitDatum == playersCurrentDatum)
			{
				return makeInvulnerable(ctx);
			}

			LOG_ONCE_CAPTURE(PLOG_DEBUG << "playersCurrentDatum: " << datum, datum = playersCurrentDatum);

			// update address of players biped data

			auto playerAddress = instance->getObjectAddress->getObjectAddress(playersCurrentDatum, CommonObjectType::Biped);
			LOG_ONCE_CAPTURE(PLOG_DEBUG << "updating playerDataStructs currentBaseAddress: " << std::hex << addy, addy = playerAddress);
			instance->playerDataStruct->currentBaseAddress = playerAddress;

			// get current vehicle datum
			LOG_ONCE(PLOG_DEBUG << "looking up playersCurrentVehicleDatum");
			Datum playersCurrentVehicleDatum = *instance->playerDataStruct->field<Datum>(bipedDataFields::currentVehicleDatum);
			LOG_ONCE_CAPTURE (PLOG_DEBUG << "playersCurrentVehicleDatum: " << datum, datum = playersCurrentVehicleDatum);

			// if the current damaged unit is the players current vehicle, make invuln!
			if (currentlyDamagedUnitDatum == playersCurrentVehicleDatum && playersCurrentVehicleDatum != nullDatum)
			{
				// check if the player is actually BOARDING this vehicle, in which case we don't want to make it invuln
				if (!playerIsBoarding())
				{
					LOG_ONCE_CAPTURE(PLOG_VERBOSE << "making players vehicle invuln!: " << datum, datum = currentlyDamagedUnitDatum);
					return makeInvulnerable(ctx);
				}
				else
				{
					LOG_ONCE_CAPTURE(PLOG_VERBOSE << "not making players boarded vehicle invuln!: " << datum, datum = currentlyDamagedUnitDatum);
					return;
				}

			}

			LOG_ONCE_CAPTURE(PLOG_VERBOSE << "not making invulnerable: " << datum, datum = currentlyDamagedUnitDatum);
		}
		catch (HCMRuntimeException ex)
		{
			instance->runtimeExceptions->handleMessage(ex);
			instance->settings->invulnerabilityToggle->resetToDefaultValue();
		}




	}

	void onInvulnToggle(bool& newVal)
	{
		PLOG_DEBUG << "onInvulnToggle: newval: " << newVal;
		invulnerabilityHook->setWantsToBeAttached(newVal);
		if (mccStateHook->isGameCurrentlyPlaying(mGame))
		{
			messagesGUI->addMessage(newVal ? "Invulnerability enabled." : "Invulnerability disabled.");
		}

	}

public:
	SimpleInvulnerabilityImpl(GameState game, IDIContainer& dicon)
		: mGame(game),
		settings(dicon.Resolve<SettingsStateAndEvents>()),
		mInvulnerabilityToggleCallbackHandle(dicon.Resolve<SettingsStateAndEvents>()->invulnerabilityToggle->valueChangedEvent, [this](bool& newval) { onInvulnToggle(newval); }),
		mccStateHook(dicon.Resolve<IMCCStateHook>()),
		messagesGUI(dicon.Resolve<IMessagesGUI>()),
		runtimeExceptions(dicon.Resolve<RuntimeExceptionHandler>()),
		getPlayerDatum(resolveDependentCheat(GetPlayerDatum)),
		getObjectAddress(resolveDependentCheat(GetObjectAddress))
	{
		if (instance) throw HCMInitException("Cannot have more than one Halo1InvulnerabilityImpl");
		instance = this;



		auto ptr = dicon.Resolve<PointerManager>();
		playerDataStruct = DynamicStructFactory::make<bipedDataFields>(ptr, game);
		invulnerabilityFunction = ptr->getData<std::shared_ptr<MultilevelPointer>>("invulnerabilityFunction", game);
		invulnerabilityFunctionContext = ptr->getData<std::shared_ptr<MidhookContextInterpreter>>("invulnerabilityFunctionContext", game);
		invulnerabilityHook = ModuleMidHook::make(game.toModuleName(), invulnerabilityFunction, invulnerabilityHookFunction);

		try
		{
			boardingText = std::make_optional<std::shared_ptr<MultilevelPointer>>(ptr->getData<std::shared_ptr<MultilevelPointer>>(nameof(boardingText), game));
			boardingTextFlag = std::make_optional<std::shared_ptr<MultilevelPointer>>(ptr->getData<std::shared_ptr<MultilevelPointer>>(nameof(boardingTextFlag), game));
		}
		catch (HCMInitException ex)
		{
			PLOG_DEBUG << "no boarding text/flag available for game: " << game.toString();
		}

	}

	~SimpleInvulnerabilityImpl()
	{
		instance = nullptr;
	}

};




