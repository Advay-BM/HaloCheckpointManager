#pragma once
#include "pch.h"
#include "Invulnerability.h"
#include "ModuleHook.h"
#include "MultilevelPointer.h"
#include "MidhookContextInterpreter.h"
#include "PointerManager.h"
#include "SettingsStateAndEvents.h"
#include "Datum.h"
#include "RuntimeExceptionHandler.h"
#include "DIContainer.h"
#include "MCCStateHook.h"

class Halo1InvulnerabilityImpl : public InvulnerabilityImpl, public std::enable_shared_from_this<Halo1InvulnerabilityImpl>
{
private:
	static inline Halo1InvulnerabilityImpl* instance = nullptr;
	// event callbacks
	ScopedCallback<eventpp::CallbackList<void(bool&)>> mInvulnerabilityToggleCallbackHandle;
	ScopedCallback<ActionEvent> mInvulnerabilityHotkeyCallbackHandle;

	// injected services
	gsl::not_null<std::shared_ptr<MCCStateHook>> mccStateHook;
	gsl::not_null<std::shared_ptr<MessagesGUI>> messagesGUI;
	gsl::not_null<std::shared_ptr<RuntimeExceptionHandler>> runtimeExceptions;
	gsl::not_null<std::shared_ptr<SettingsStateAndEvents>> settings;
	//data
	static inline Datum* playersVehicleDatum = nullptr;
	static inline std::shared_ptr<ModuleMidHook> invulnerabilityHook;
	static inline std::shared_ptr<MultilevelPointer> invulnerabilityFunction;
	static inline std::shared_ptr<MidhookContextInterpreter> invulnerabilityFunctionContext;
	static inline std::shared_ptr<MultilevelPointer> playerDatum;

	static void invulnerabilityHookFunction(SafetyHookContext& ctx)
	{
		//LOG_ONCE(PLOG_DEBUG << "capturing shared_from_this()");
		//auto guard = instance->shared_from_this();
		//LOG_ONCE(PLOG_DEBUG << "captured shared_from_this()");
#define makeInvuln() ctx.rflags = ctx.rflags | (1UL << 6)	// set zero flag to true if should be invuln


		if (instance->settings->invulnerabilityNPCToggle->GetValue())
		{
			makeInvuln();
			return;
		}

		enum class param
		{
			unitDatum,
			playersVehicleDatum,
		};
		auto* ctxInterpreter = invulnerabilityFunctionContext.get();
		Datum currentDatum = *(Datum*)ctxInterpreter->getParameterRef(ctx, (int)param::unitDatum);
		Datum playersCurrentDatum;

		if (!playerDatum->readData<Datum>(&playersCurrentDatum)) // this shouldn't ever fail
		{
			HCMInitException ex(std::format("Could not read players current datum, disabling invulnerability!"));
			instance->runtimeExceptions->handleMessage(ex);
			instance->settings->invulnerabilityToggle->resetToDefaultValue();
			return;
		}

		if (playersCurrentDatum == nullDatum) return; // might happen when the player is dead, depending on game version / pointer used

		// check if current actor is player
		if (currentDatum == playersCurrentDatum)
		{
			// store vehicle datum
			playersVehicleDatum = (Datum*)ctxInterpreter->getParameterRef(ctx, (int)param::playersVehicleDatum);
			PLOG_DEBUG << "playersVehicleDatum: " << playersVehicleDatum;
			makeInvuln();
			return;
		}

		// check if current actor is players vehicle
		// this can break if the player goes without getting damaged > changes address > gets in vehicle
		// a more robust implementation would probably use some sort of ObjectLookup service on the player datum
		if (!IsBadReadPtr(playersVehicleDatum, sizeof(Datum)))
		{
			auto playersCurrentVehicleDatum = *playersVehicleDatum;
				if (currentDatum == playersCurrentVehicleDatum && playersCurrentVehicleDatum != nullDatum)
				{
					PLOG_DEBUG << "Making players vehicle invuln: " << currentDatum;
						makeInvuln();
						return;
				}
		}



	}

	void onInvulnToggle(bool& newVal)
	{
		PLOG_DEBUG << "onInvulnToggle: newval: " << newVal;
		invulnerabilityHook->setWantsToBeAttached(newVal);
	}

public:
	Halo1InvulnerabilityImpl(GameState game, IDIContainer& dicon)
		: settings(dicon.Resolve<SettingsStateAndEvents>()),
		mInvulnerabilityToggleCallbackHandle(dicon.Resolve<SettingsStateAndEvents>()->invulnerabilityToggle->valueChangedEvent, [this](bool& newval) { onInvulnToggle(newval); }),
		mInvulnerabilityHotkeyCallbackHandle(dicon.Resolve<SettingsStateAndEvents>()->invulnerabilityHotkeyEvent, [invulnerabilityToggle = dicon.Resolve<SettingsStateAndEvents>()->invulnerabilityToggle]()
			{
				invulnerabilityToggle->flipBoolSetting();
			}),
		mccStateHook(dicon.Resolve<MCCStateHook>()),
		messagesGUI(dicon.Resolve<MessagesGUI>()),
		runtimeExceptions(dicon.Resolve<RuntimeExceptionHandler>())
	{
		if (instance) throw HCMInitException("Cannot have more than one Halo1InvulnerabilityImpl");
		instance = this;

		auto ptr = dicon.Resolve<PointerManager>();
		invulnerabilityFunction = ptr->getData<std::shared_ptr<MultilevelPointer>>("invulnerabilityFunction", game);
		invulnerabilityFunctionContext = ptr->getData<std::shared_ptr<MidhookContextInterpreter>>("invulnerabilityFunctionContext", game);
		invulnerabilityHook = ModuleMidHook::make(L"halo1", invulnerabilityFunction, invulnerabilityHookFunction);
		playerDatum = ptr->getData<std::shared_ptr<MultilevelPointer>>("playerDatum", game);

	}

};




