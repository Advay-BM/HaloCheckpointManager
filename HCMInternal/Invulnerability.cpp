#include "pch.h"
#include "Invulnerability.h"
#include "ModuleHook.h"
#include "MultilevelPointer.h"
#include "MidhookContextInterpreter.h"
#include "PointerManager.h"
#include "OptionsState.h"
class Invulnerability::InvulnerabilityImpl
{
private:
	GameState mGameImpl;

	//static std::map<GameState, std::unique_ptr<std::mutex>> getDGuards()
	//{
	//	std::map<GameState, std::unique_ptr<std::mutex>> dg;
	//	dg.emplace(std::piecewise_construct, std::tuple(GameState::Value::Halo1), std::tuple());
	//	dg.emplace(std::piecewise_construct, std::tuple(GameState::Value::Halo2), std::tuple());
	//	dg.emplace(std::piecewise_construct, std::tuple(GameState::Value::Halo3), std::tuple());
	//	dg.emplace(std::piecewise_construct, std::tuple(GameState::Value::Halo3ODST), std::tuple());
	//	dg.emplace(std::piecewise_construct, std::tuple(GameState::Value::HaloReach), std::tuple());
	//	dg.emplace(std::piecewise_construct, std::tuple(GameState::Value::Halo4), std::tuple());
	//	return dg;
	//}
	static inline std::map<GameState, std::mutex> mDestructionGuards{};




	static void invulnerabilityHookFunction_H1(SafetyHookContext& ctx);
	static void invulnerabilityHookFunction_H2(SafetyHookContext& ctx);

	std::shared_ptr<ModuleMidHook> invulnerabilityHook;

	std::shared_ptr<MultilevelPointer> invulnerabilityFunction;
	std::shared_ptr<MidhookContextInterpreter> invulnerabilityFunctionContext;

	eventpp::CallbackList<void(bool&)>::Handle invulnerabilityToggleEventCallbackHandle;
	void onToggle(bool newVal)
	{
		invulnerabilityHook.get()->setWantsToBeAttached(newVal);
	}


public:
	InvulnerabilityImpl(GameState game) : mGameImpl(game)
	{
		invulnerabilityFunction = PointerManager::getData<std::shared_ptr<MultilevelPointer>>("invulnerabilityFunction", mGameImpl);
		invulnerabilityFunctionContext = PointerManager::getData<std::shared_ptr<MidhookContextInterpreter>>("invulnerabilityFunctionContext", mGameImpl);

		switch (game)
		{
		case GameState::Value::Halo1:
			invulnerabilityHook = ModuleMidHook::make(L"halo1", invulnerabilityFunction, invulnerabilityHookFunction_H1);
			break;
		case GameState::Value::Halo2:
			invulnerabilityHook = ModuleMidHook::make(L"halo2", invulnerabilityFunction, invulnerabilityHookFunction_H2);
			break;
		default:
			throw HCMInitException("not impl yet");
		}

		// subscribe to option event
		invulnerabilityToggleEventCallbackHandle = OptionsState::invulnerabilityToggle.get()->valueChangedEvent.append([this](bool& b) {onToggle(b); });
	}

	~InvulnerabilityImpl()
	{
		std::scoped_lock lock (mDestructionGuards[mGameImpl]);
		// unsubscribe from option event
		if (invulnerabilityToggleEventCallbackHandle)
			OptionsState::invulnerabilityToggle.get()->valueChangedEvent.remove(invulnerabilityToggleEventCallbackHandle);

		// destroy hooks (while destruction guard locked)
		invulnerabilityHook.reset();
	}
};




Invulnerability::Invulnerability(GameState game) : CheatBase(game) {}
Invulnerability::~Invulnerability() = default; // https://www.fluentcpp.com/2017/09/22/make-pimpl-using-unique_ptr/
void Invulnerability::initialize()
{
	// impl throws HCMInitException on failure
	impl = std::make_unique<InvulnerabilityImpl>(mGame);
}


void Invulnerability::InvulnerabilityImpl::invulnerabilityHookFunction_H1(SafetyHookContext& ctx)
{
	std::scoped_lock lock(mDestructionGuards[GameState::Value::Halo1]);



	// set zero flag to true if should be invuln
	ctx.rflags = ctx.rflags | (1UL << 6);

}

void Invulnerability::InvulnerabilityImpl::invulnerabilityHookFunction_H2(SafetyHookContext& ctx)
{
	std::scoped_lock lock(mDestructionGuards[GameState::Value::Halo2]);
}